# SIMON算法轮函数汇编实现分析

## 对16位的循环左移操作

本部分讨论不同循环左移位数的最优实现方案，这里的“最优方案”仅考虑最少的汇编指令条数。 

以下操作均对0x6544进行循环移位，待移位数据保存在20H, 21H，移位结果保存在26H，27H。
```
    MOV 0x20, #0x65
    MOV 0x21, #0x44
```

### 循环左移8位

直接交换
```
    MOV 0x26, 0x21
    MOV 0x27, 0x20
```

### 循环左移1位、9位

1. 循环左移1位
```
    MOV A, 0x20
    MOV C, 21H.7
    RLC A
    MOV 0x26, A
    MOV A, 0x21
    RLC A
    MOV 0x27, A
```

2. 循环左移9位
```
    MOV A, 0x21
    MOV C, 20H.7
    RLC A
    MOV 0x26, A
    MOV A, 0x20
    RLC A
    MOV 0x27, A
```
循环左移1位和9位，依靠两次带进位左移实现。

### 循环左移15位、7位

1. 循环左移15位
```
    MOV A, 0x20 
    MOV C , 21H.0
    RRC A
    MOV 0x26, A
    MOV A, 21H
    RRC A
    MOV 0x27, A
```

2. 循环左移7位
```
    MOV A, 0x21 
    MOV C , 20H.0
    RRC A
    MOV 0x26, A
    MOV A, 0x20
    RRC A
    MOV 0x27, A
```
循环左移15位和7位，依靠两次带进位右移实现。

### 其他循环左移位数 

剩下的循环左移位数实现的思想依靠乘、除、与、或等操作，按照要左移的位数把16比特划分为4个部分（乘、除、与实现），把4个部分重新组合（或实现）。下面代码展示了如何循环左移两比特。
```
    MOV A, 0x20
    ANL A, #0xC0
    MOV B, #0x40
    DIV AB
    MOV 0x0A, A  ;tmp1

    MOV A, 0x20
    ANL A, #0x3F
    MOV B, #0x04
    MUL AB
    MOV 0x0B, A ;tmp2

    MOV A, 0x21
    ANL A, #0xC0
    MOV B, #0x40
    DIV AB
    MOV 0x0C, A ;tmp3

    MOV A, 0x21
    ANL A, #0x3F
    MOV B, #0x04
    MUL AB
    MOV 0x0D, A ;tmp4

    MOV A, 0x0B
    ORL A, 0x0C
    MOV 0x26, A
    MOV A, 0x0A
    ORL A, 0x0D
    MOV 0x27, A
```

## SIMON第一轮完整汇编实现 

```
    MOV 0x20, #0x65  ;L
    MOV 0x21, #0x44
    MOV 0x22, #0x68  ;R
    MOV 0x23, #0x77 
    MOV 0x24, #0x01  ;K
    MOV 0x25, #0x00

    ;循环左移1位 
    MOV A, 0x20
    MOV C, 21H.7
    RLC A
    MOV 0x26, A
    MOV A, 0x21
    RLC A
    MOV 0x27, A

    ;循环左移8位加非线性操作
    MOV A, 0x26
    ANL A, 0x21
    MOV 0x26, A
    MOV A, 0x27
    ANL A, 0x20
    MOV 0x27, A

    ;循环左移两位加异或操作
    MOV A, 0x20
    ANL A, #0xC0
    MOV B, #0x40
    DIV AB
    MOV 0x0A, A  ;tmp1

    MOV A, 0x20
    ANL A, #0x3F
    MOV B, #0x04
    MUL AB
    MOV 0x0B, A ;tmp2

    MOV A, 0x21
    ANL A, #0xC0
    MOV B, #0x40
    DIV AB
    MOV 0x0C, A ;tmp3

    MOV A, 0x21
    ANL A, #0x3F
    MOV B, #0x04
    MUL AB
    MOV 0x0D, A ;tmp4

    MOV A, 0x0B
    ORL A, 0x0C
    XRL A, 0x26
    MOV 0x26, A
    MOV A, 0x0A
    ORL A, 0x0D
    XRL A, 0x27
    MOV 0x27, A
    
    ;与R异或
    MOV A, 0x26
    XRL A, 0x22
    MOV 0x26, A
    MOV A, 0x27
    XRL A, 0x23
    MOV 0x27, A    
    
    ;与k异或
    MOV A, 0x24
    XRL A, 0x26
    MOV 0x26, A
    MOV A, 0x25
    XRL A, 0x27
    MOV 0x27, A

```

# 逆向SIMON轮函数

假设SIMON轮函数未公开，攻击者只知道SIMON算法是Feistel结构，轮输入输出的位宽都是32比特，轮数是32轮，密钥位宽64比特。

攻击者实验条件：

1. 可任选明文与密钥，采集设备加密时的能量波形；

2. 可恢复轮函数的每一条汇编指令（SPA实现）；

待解决问题：

1. 恢复SIMON轮函数内部结构

2. 恢复所有指令的操作数

明文32比特，左16比特表示为L0，右16比特表示为R0，第1轮子密钥为K0。 

## 逆向SIMON轮函数结构

R1 = L0， L1 = F(L0) ^ R0 ^ K0，我们要恢复轮函数F。轮函数F包含线性操作和非线性操作，假设线性操作只有循环移位（左移、右移），移位的位数是任意的（1-15），非线性操作有与、异或、模加，暂不考虑查表，F是上述操作的任意组合。

### 恢复线性操作 

随机L0，穷举所有移位情况（30种），与采集的波形做相关性分析，判断出F包含哪几种移位操作。

### 恢复非线性操作 

固定L0，随机R0，固定K0，通过CPA方法恢复F(L0) 的值。由于我们已经恢复出F内部的线性操作，现在又已知F输出值，可逆向推出非线性操作。

## 恢复各个指令的操作数

现已知SIMON内部轮函数结构，通过眀密文相关性可确定各个操作的开始位置和起始位置，从而把第一轮的汇编指令按照操作进行分组，例如对L0的循环左移1位操作对应于汇编语句的第7条到第13条。结合每组的操作以及相关性分析，很容易的去恢复各个指令的操作数。

下面的代码是对应循环左移1位的代码序列：

```
    MOV ;1 
    MOV ;2
    RLC ;3
    MOV ;4
    MOV ;5
    RLC ;6
    MOV ;7
```

对L0的第一字节（左8比特）做相关性分析，指令1、3的相关性很高；对L0的第二字节做相关性分析，指令5、6的相关性很高；指令4与移位结果第一字节有跟高的相关性，指令7与移位结果第二字节有很高的相关性；指令2的操作数根据循环左移1位的实现逻辑看，可判断其操作数为L0第二字节的最高位。

针对ANL、ORL、XRL、MUL、DIV等有两个操作数的汇编指令，要注意把两个操作数都恢复出来。




